#'
#' @return A list with two components:
#' \describe{
#'   \item{\code{var1}}{Covariance matrix of the naive logistic regression estimates.}
#'   \item{\code{Naive estimates}}{Matrix of naive logistic regression results,
#'         including coefficient estimates, standard errors, z-values,
#'         p-values, odds ratios (OR), and 95\% confidence intervals on the
#'         original scale.}
#' }
#'
#' @details
#' This function is typically used as the first step in an internal reliability
#' study to illustrate the bias introduced by ignoring measurement error.
#' It scales coefficients and their standard errors back to the original scale
#' using the supplied standard deviations.
#'
#' @examples
#' set.seed(1)
#' # Simulated internal data: 100 subjects, 2 replicates of 1 exposure
#' z.rep <- cbind(rnorm(100), rnorm(100))
#' zbar <- rowMeans(z.rep)
#' Y <- rbinom(100, 1, plogis(0.5 * zbar))
#'
#' # Standardize and get SDs
#' zbar.std <- scale(zbar)
#' sdz <- sd(zbar)
#'
#' # Run naive logistic regression ignoring measurement error
#' res <- naive_analysis_in_log(
#'   zbar = zbar.std,
#'   W.std = NULL,
#'   Y = Y,
#'   sdz = sdz,
#'   sdw = NULL
#' )
#' str(res)
#'
#' @noRd
#' @export
naive_analysis_in_log = function(Y, zbar, W.std = NULL, sdz, sdw){
z_df = as.data.frame(zbar)
colnames(z_df) = colnames(zbar)
if(is.null(W.std)){
model_df = data.frame(Y = Y, z_df)
fit1 = glm(Y ~ ., data = model_df, family = "binomial")
beta.fit1 = fit1$coefficients #naive estimator
var1 = vcov(fit1) #naive covariance matrix
tab1 = summary(fit1)$coefficients
tab1[,1:2] = tab1[,1:2]/c(1,sdz)
CI.low = tab1[,1]-1.96*tab1[,2]
CI.high = tab1[,1]+1.96*tab1[,2]
tab1 = cbind(tab1,exp(cbind(OR = tab1[, 1],CI.low,CI.high)))
}
else{
W_df = as.data.frame(W.std)
colnames(W_df) = colnames(W.std)
model_df = data.frame(Y = Y, z_df, W_df)
fit1 = glm(Y ~ ., data = model_df, family = "binomial")
beta.fit1 = fit1$coefficients #naive estimator
var1 = vcov(fit1) #naive covariance matrix
tab1 = summary(fit1)$coefficients
tab1[,1:2] = tab1[,1:2]/c(1,sdz,sdw)
CI.low = tab1[,1]-1.96*tab1[,2]
CI.high = tab1[,1]+1.96*tab1[,2]
tab1 = cbind(tab1,exp(cbind(OR = tab1[, 1],CI.low,CI.high)))
}
list(
var1 = var1,
`Naive estimates` = tab1
)
}
set.seed(1)
# Simulated internal data: 100 subjects, 2 replicates of 1 exposure
z.rep <- cbind(rnorm(100), rnorm(100))
zbar <- rowMeans(z.rep)
Y <- rbinom(100, 1, plogis(0.5 * zbar))
# Standardize and get SDs
zbar.std <- scale(zbar)
sdz <- sd(zbar)
# Run naive logistic regression ignoring measurement error
res <- naive_analysis_in_log(
zbar = zbar.std,
W.std = NULL,
Y = Y,
sdz = sdz,
sdw = NULL
)
#' Prepare and Standardize Data for Internal Reliability Study
#'
#' \code{prepare_data_in()} processes replicate measurements from an internal
#' reliability study, constructs replicate counts, computes subject-level
#' averages, and standardizes exposures (and optional covariates). It returns
#' replicate-level and subject-level standardized data for downstream naive,
#' calibration, and sandwich analyses.
#'
#' Typical usage:
#' \enumerate{
#'   \item Pads each replicate matrix to match the maximum number of replicates.
#'   \item Computes pooled means and standard deviations across all replicates.
#'   \item Standardizes replicate-level data and subject-level averages.
#'   \item Standardizes optional covariates if supplied.
#'   \item Returns standardized replicates, averages, replicate counts, and
#'         auxiliary information.
#' }
#'
#' @param r Integer vector of length \eqn{n}, giving the number of replicates
#'   available for each subject.
#' @param z A named list of length \eqn{t}; each element is an \eqn{n \times r_i}
#'   matrix of replicate measurements for one error-prone exposure. Different
#'   exposures may have different numbers of replicates.
#' @param W Optional numeric matrix of covariates without measurement error
#'   (\eqn{n \times q}). If supplied, all covariates are centered and scaled.
#' @param Y Outcome vector of length \eqn{n}.
#'
#' @return A list containing:
#' \describe{
#'   \item{\code{z.std}}{List of standardized replicate matrices, each padded to
#'         the maximum number of replicates.}
#'   \item{\code{zbar}}{Matrix (\eqn{n \times t}) of standardized subject-level
#'         averages of replicates.}
#'   \item{\code{W.std}}{Standardized covariate matrix (\eqn{n \times q}) if
#'         \code{W} is supplied.}
#'   \item{\code{Y}}{Outcome vector of length \eqn{n}.}
#'   \item{\code{r}}{Integer vector of replicate counts of length \eqn{n}.}
#'   \item{\code{means}}{List of means used for standardization: \code{z} for
#'         exposures, and \code{w} for covariates if applicable.}
#'   \item{\code{sds}}{List of standard deviations used for standardization:
#'         \code{z} for exposures, and \code{w} for covariates if applicable.}
#' }
#'
#' @examples
#' set.seed(123)
#' # Internal study: 5 subjects, 1 exposure with 2 replicates
#' z <- list(
#'   sbp = cbind(rnorm(5, 120, 15), rnorm(5, 120, 15))
#' )
#'
#' # Replicate counts (each subject has 2 replicates)
#' r <- rep(2, 5)
#'
#' # Outcome and optional covariate
#' Y <- rbinom(5, 1, 0.5)
#' W <- matrix(rnorm(5), ncol = 1)
#' colnames(W) <- "age"
#'
#' # Prepare and standardize data
#' prep <- prepare_data_in(r = r, z = z, W = W, Y = Y)
#' str(prep)
#'
#' @noRd
#' @export
prepare_data_in = function(r, z, W = NULL, Y) {
n = length(r)
t = length(z)
z_name = names(z)
z = lapply(1:t, function(x) {
zx <- z[[x]]
pad_cols <- max(r) - ncol(zx)
if (pad_cols > 0) {
zx <- cbind(zx, matrix(NA, nrow = n, ncol = pad_cols))
}
zx
})
meanz = sapply(z, function(x) colMeans(x, na.rm = TRUE))[1, ]
sdz = sapply(z, function(x) apply(x, 2, function(y) sd(y, na.rm = TRUE)))[1, ]
z.std = sapply(1:t, function(x) (z[[x]] - meanz[x]) / sdz[x], simplify = FALSE)
names(z.std) = z_name
if (is.null(W)) {
zbar = sapply(z.std, function(y) rowMeans(y, na.rm = TRUE))
names(zbar) = z_name
return(list(
means = list(z = meanz),
z.std = z.std,
sds   = list(z = sdz),
Y     = Y,
zbar  = zbar,
r = r
))
}
else {
W = as.matrix(W)
t = length(z)
q = ncol(W)
meanw = colMeans(W)
sdw = apply(W, 2, function(y) sd(y, na.rm = TRUE))
W.new = sapply(1:q, function(x) (W[, x] - meanw[x]) / sdw[x])
colnames(W.new) = colnames(W)
zbar = sapply(z.std, function(y) rowMeans(y, na.rm = TRUE))
names(zbar) = names(z)
return(list(
W.std = W.new,
means = list(z = meanz, w = meanw),
sds   = list(z = sdz, w = sdw),
zbar  = zbar,
Y = Y,
z.std = z.std,
r = r
))
}
}
set.seed(123)
# Internal study: 5 subjects, 1 exposure with 2 replicates
z <- list(
sbp = cbind(rnorm(5, 120, 15), rnorm(5, 120, 15))
)
# Replicate counts (each subject has 2 replicates)
r <- rep(2, 5)
# Outcome and optional covariate
Y <- rbinom(5, 1, 0.5)
W <- matrix(rnorm(5), ncol = 1)
colnames(W) <- "age"
# Prepare and standardize data
prep <- prepare_data_in(r = r, z = z, W = W, Y = Y)
set.seed(1)
# Simulated internal data: 100 subjects, 2 replicates of 1 exposure
z.rep <- cbind(rnorm(100), rnorm(100))
zbar <- rowMeans(z.rep)
Y <- rbinom(100, 1, plogis(0.5 * zbar))
# Standardize and get SDs
zbar.std <- scale(zbar)
sdz <- sd(zbar)
# Run naive logistic regression ignoring measurement error
res <- naive_analysis_in_log(
zbar = zbar.std,
W.std = NULL,
Y = Y,
sdz = sdz,
sdw = NULL
)
set.seed(123)
# Internal reliability study: 60 subjects, 2 replicates of 1 exposure
z.rep <- cbind(rnorm(60), rnorm(60))
zbar <- rowMeans(z.rep)
Y <- rbinom(60, 1, plogis(0.4 * zbar))
# Standardize data
zbar.std <- scale(zbar)
sdz <- sd(zbar)
z.std <- list(sbp = scale(z.rep))
r <- rep(2, 60) # each subject has 2 replicates
# Naive covariance (for dimension labels)
naive <- naive_analysis_in_log(Y = Y, zbar = zbar.std, W.std = NULL,
sdz = sdz, sdw = NULL)
# Apply regression calibration
fit <- reg_calibration_in_log(
Y = Y,
zbar = as.matrix(zbar.std),
z.std = z.std,
W.std = NULL,
muz = mean(zbar),
muw = NULL,
sdz = sdz,
sdw = NULL,
r = r,
var1 = naive$var1
)
str(fit)
set.seed(1)
# Simulated internal data: 80 subjects, 2 replicates of 1 exposure
z.rep <- cbind(rnorm(80), rnorm(80))
zbar <- rowMeans(z.rep)
Y <- 2 + 0.5 * zbar + rnorm(80)
# Standardize and get SDs
zbar.std <- scale(zbar)
sdz <- sd(zbar)
# Run naive linear regression ignoring measurement error
res <- naive_analysis_in_linear(
zbar = zbar.std,
W.std = NULL,
Y = Y,
sdz = sdz,
sdw = NULL
)
set.seed(123)
# Internal reliability study: 60 subjects, 2 replicates of 1 exposure
z.rep <- cbind(rnorm(60), rnorm(60))
zbar <- rowMeans(z.rep)
Y <- 2 + 0.5 * zbar + rnorm(60)
# Standardize data
zbar.std <- scale(zbar)
sdz <- sd(zbar)
z.std <- list(sbp = scale(z.rep))
r <- rep(2, 60) # each subject has 2 replicates
# Naive covariance (for dimension labels)
naive <- naive_analysis_in_linear(Y = Y, zbar = zbar.std, W.std = NULL,
sdz = sdz, sdw = NULL)
# Apply regression calibration
fit <- reg_calibration_in_linear(
Y = Y,
zbar = as.matrix(zbar.std),
z.std = z.std,
W.std = NULL,
muz = mean(zbar),
muw = NULL,
sdz = sdz,
sdw = NULL,
r = r,
var1 = naive$var1
)
set.seed(123)
# Simulated replicate data: 100 subjects, 1 exposure with 2 replicates
z.rep <- cbind(rnorm(100), rnorm(100))
zbar <- rowMeans(z.rep)
Y <- rpois(100, exp(0.3 + 0.5 * zbar))
sdz <- sd(zbar)
# Run naive Poisson regression
res <- naive_analysis_in_poisson(
Y = Y,
zbar = scale(zbar),
W.std = NULL,
sdz = sdz,
sdw = NULL
)
set.seed(123)
# Internal reliability study: 60 subjects, 2 replicates of 1 exposure
z.rep <- cbind(rnorm(60), rnorm(60))
zbar <- rowMeans(z.rep)
Y <- rpois(60, lambda = exp(0.2 + 0.5 * zbar))
# Standardize data
zbar.std <- scale(zbar)
sdz <- sd(zbar)
z.std <- list(sbp = scale(z.rep))
r <- rep(2, 60)
# Naive covariance (for dimension labels)
naive <- naive_analysis_in_poisson(Y = Y, zbar = zbar.std,
W.std = NULL, sdz = sdz, sdw = NULL)
# Apply regression calibration
fit <- reg_calibration_in_poisson(
Y = Y,
zbar = as.matrix(zbar.std),
z.std = z.std,
W.std = NULL,
muz = mean(zbar),
muw = NULL,
sdz = sdz,
sdw = NULL,
r = r,
var1 = naive$var1
)
library(RegCalReliab)
library(mgcv)
set.seed(123)
# Helper for measurement error
add_err = function(v, sd = sqrt(0.4)) v + rnorm(length(v), 0, sd)
# True slope and OR
beta = log(1.5)
OR_true = 1.5
simulate_once = function() {
# ---- True covariates ----
x = mgcv::rmvn(3000, c(0,0,0),
matrix(c(1,0.3,0.2,
0.3,1,0.5,
0.2,0.5,1), nrow = 3))
# Binary W2 depends on x1
w2 = sapply(x[,1], function(t) {
if (t > median(x[,1])) rbinom(1,1,0.5) else rbinom(1,1,0.3)
})
# Error-free covariates
W = cbind(x[,3], w2)
colnames(W) = c("W1", "W2")
# ---- Replicate design ----
r = c(rep(1,1500), rep(2,500), rep(3,400), rep(4,600))
# Replicates for z1
z1 = rbind(
cbind(add_err(x[1:1500, 1]), NA, NA, NA),
cbind(add_err(x[1501:2000, 1]), add_err(x[1501:2000, 1]), NA, NA),
cbind(add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), NA),
cbind(add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]))
)
colnames(z1) = paste0("z1_",1:4)
# Replicates for z2
z2 = rbind(
cbind(add_err(x[1:1500, 2]), NA, NA, NA),
cbind(add_err(x[1501:2000, 2]), add_err(x[1501:2000, 2]), NA, NA),
cbind(add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), NA),
cbind(add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]))
)
colnames(z2) = paste0("z2_",1:4)
# ---- Outcome ----
p = plogis(-2.65 + beta*rowSums(x[,1:3]) + beta*w2)
Y = rbinom(3000, 1, p)
# ---- Main data with outcome, replicates, covariates ----
main_data = data.frame(Y, z1, z2, W)
# ---- Regression calibration ----
res = RC_InReliab(
formula   = Y ~ myz1(z1_1, z1_2, z1_3, z1_4) +
myz2(z2_1, z2_2, z2_3, z2_4) +
W1 + W2,
main_data = main_data,
link      = "logistic"
)
return(res)
}
B = 10
results_list = replicate(B, simulate_once(), simplify = FALSE)
# Collect naïve + corrected tables
naive_tabs = lapply(results_list, function(x) x$uncorrected)
corrected_tabs = lapply(results_list, function(x) x$corrected)
avg_naive = Reduce("+", naive_tabs) / B
avg_corrected = Reduce("+", corrected_tabs) / B
cat("\nAverage Naive Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_naive, 5))
cat("\nAverage Corrected Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_corrected, 5))
inside_ci = function(tab, i, truth = OR_true) {
ci = tab[i , c("CI.low", "CI.high")]
ci[1] <= truth && truth <= ci[2]
}
row_z1 = which(rownames(avg_naive) == "myz1")
row_z2 = which(rownames(avg_naive) == "myz2")
coverage = function(tab_list, row) {
mean(sapply(tab_list, function(tab) inside_ci(tab, row))) * 100
}
cov_z1_naive = coverage(naive_tabs, row_z1)
cov_z1_corr = coverage(corrected_tabs, row_z1)
cov_z2_naive = coverage(naive_tabs, row_z2)
cov_z2_corr = coverage(corrected_tabs, row_z2)
cat("\nCoverage of TRUE OR = 1.5 for error-prone exposure z1:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z1_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z1_corr))
cat("\nCoverage of TRUE OR = 1.5 for error-prone exposure z2:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z2_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z2_corr))
# --- Pull all z1 and z2 estimates and reported SEs (corrected) ---
z1_correct_est <- sapply(corrected_tabs, function(tab) tab["myz1", "Estimate"])
z1_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz1", "Std. Error"])
z2_correct_est <- sapply(corrected_tabs, function(tab) tab["myz2", "Estimate"])
z2_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz2", "Std. Error"])
# --- Monte Carlo SD (empirical) ---
sd_mc1 <- sd(z1_correct_est, na.rm = TRUE)
sd_mc2 <- sd(z2_correct_est, na.rm = TRUE)
# --- Average model-based SE (Estimated SE, ESE/ASE) ---
mean_se1 <- mean(z1_correct_se, na.rm = TRUE)
mean_se2 <- mean(z2_correct_se, na.rm = TRUE)
# --- Optional direct comparison and ratio ---
cat("\nCorrected z1:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc1))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se1))
cat("\nCorrected z2:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc2))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se2))
set.seed(123)
add_err <- function(v, sd = sqrt(0.4)) v + rnorm(length(v), 0, sd)
## --- Example 1: Internal 1Z 0W ---
x <- rnorm(3000)
z <- rbind(
cbind(add_err(x[1:1500]), NA, NA, NA),
cbind(add_err(x[1501:2000]), add_err(x[1501:2000]), NA, NA),
cbind(add_err(x[2001:2400]), add_err(x[2001:2400]), add_err(x[2001:2400]), NA),
cbind(add_err(x[2401:3000]), add_err(x[2401:3000]), add_err(x[2401:3000]), add_err(x[2401:3000]))
)
colnames(z) <- paste0("z_", 1:4)
Y <- rbinom(3000, 1, plogis(-2.65 + log(1.5) * x))
main_data <- data.frame(Y, z)
res1 <- RC_InReliab(Y ~ myz(z_1, z_2, z_3, z_4),
main_data = main_data,
link = "logistic")
res1$corrected
x  <- rnorm(3000)
W1 <- rnorm(3000)
z <- rbind(
cbind(add_err(x[1:1500]), NA, NA, NA),
cbind(add_err(x[1501:2000]), add_err(x[1501:2000]), NA, NA),
cbind(add_err(x[2001:2400]), add_err(x[2001:2400]), add_err(x[2001:2400]), NA),
cbind(add_err(x[2401:3000]), add_err(x[2401:3000]), add_err(x[2401:3000]), add_err(x[2401:3000]))
)
colnames(z) <- paste0("z_", 1:4)
Y <- rbinom(3000, 1, plogis(-2.65 + log(1.5) * x + 0.5 * W1))
main_data <- data.frame(Y, z, W1)
res2 <- RC_InReliab(Y ~ myz(z_1, z_2, z_3, z_4) + W1,
main_data = main_data,
link = "logistic")
res2$corrected
x <- mgcv::rmvn(3000, c(0,0), matrix(c(1,0.3,0.3,1), 2))
z1 <- rbind(
cbind(add_err(x[1:1500, 1]), NA, NA, NA),
cbind(add_err(x[1501:2000, 1]), add_err(x[1501:2000, 1]), NA, NA),
cbind(add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), NA),
cbind(add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]))
)
colnames(z1) <- paste0("z1_", 1:4)
z2 <- rbind(
cbind(add_err(x[1:1500, 2]), NA, NA, NA),
cbind(add_err(x[1501:2000, 2]), add_err(x[1501:2000, 2]), NA, NA),
cbind(add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), NA),
cbind(add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]))
)
colnames(z2) <- paste0("z2_", 1:4)
Y <- rbinom(3000, 1, plogis(-2.65 + log(1.5) * rowSums(x)))
main_data <- data.frame(Y, z1, z2)
res3 <- RC_InReliab(
Y ~ myz1(z1_1, z1_2, z1_3, z1_4) + myz2(z2_1, z2_2, z2_3, z2_4),
main_data = main_data,
link = "logistic")
res3$corrected
remove.packages("RegCalReliab")
library(devtools)
document()
install()
library(devtools)
document()
document()
document()
document()
read.dcf("DESCRIPTION")
document()
library(devtools)
document()
read.dcf("DESCRIPTION")
read.dcf("DESCRIPTION")
document()
install()
test()
