simulate_once = function() {
# ---- True covariates ----
x = mgcv::rmvn(3000, c(0,0,0),
matrix(c(1,0.3,0.2,
0.3,1,0.5,
0.2,0.5,1), nrow = 3))
# Binary W2 depends on x1
w2 = sapply(x[,1], function(t) {
if (t > median(x[,1])) rbinom(1,1,0.5) else rbinom(1,1,0.3)
})
# Error-free covariates
W = cbind(x[,3], w2)
colnames(W) = c("W1", "W2")
# ---- Replicate design ----
r = c(rep(1,1500), rep(2,500), rep(3,400), rep(4,600))
# Replicates for z1
z1 = rbind(
cbind(add_err(x[1:1500, 1]), NA, NA, NA),
cbind(add_err(x[1501:2000, 1]), add_err(x[1501:2000, 1]), NA, NA),
cbind(add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), NA),
cbind(add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]))
)
colnames(z1) = paste0("z1_",1:4)
# Replicates for z2
z2 = rbind(
cbind(add_err(x[1:1500, 2]), NA, NA, NA),
cbind(add_err(x[1501:2000, 2]), add_err(x[1501:2000, 2]), NA, NA),
cbind(add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), NA),
cbind(add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]))
)
colnames(z2) = paste0("z2_",1:4)
# ---- Poisson outcome ----
# Model: log(E[Y]) = -2.65 + beta*(x1 + x2 + x3) + beta*w2
mu = exp(-2.65 + beta * rowSums(x[,1:3]) + beta * w2)
# Generate counts
Y = rpois(3000, lambda = mu)
# ---- Main data with outcome, replicates, covariates ----
main_data = data.frame(Y, z1, z2, W)
# ---- Regression calibration ----
res = RC_InReliab(
formula   = Y ~ myz1(z1_1, z1_2, z1_3, z1_4) +
myz2(z2_1, z2_2, z2_3, z2_4) +
W1 + W2,
main_data = main_data,
link      = "linear"
)
return(res)
}
B = 10
results_list = replicate(B, simulate_once(), simplify = FALSE)
# Collect naïve + corrected tables
naive_tabs = lapply(results_list, function(x) x$uncorrected)
corrected_tabs = lapply(results_list, function(x) x$corrected)
avg_naive = Reduce("+", naive_tabs) / B
avg_corrected = Reduce("+", corrected_tabs) / B
cat("\nAverage Naive Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_naive, 5))
cat("\nAverage Corrected Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_corrected, 5))
inside_ci = function(tab, i, truth = beta) {
ci = tab[i , c("CI.low", "CI.high")]
ci[1] <= truth && truth <= ci[2]
}
row_z1 = which(rownames(avg_naive) == "myz1")
row_z2 = which(rownames(avg_naive) == "myz2")
coverage = function(tab_list, row) {
mean(sapply(tab_list, function(tab) inside_ci(tab, row))) * 100
}
cov_z1_naive = coverage(naive_tabs, row_z1)
cov_z1_corr = coverage(corrected_tabs, row_z1)
cov_z2_naive = coverage(naive_tabs, row_z2)
cov_z2_corr = coverage(corrected_tabs, row_z2)
cat("\nCoverage of TRUE beta for error-prone exposure z1:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z1_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z1_corr))
cat("\nCoverage of TRUE beta for error-prone exposure z2:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z2_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z2_corr))
# --- Pull all z1 and z2 estimates and reported SEs (corrected) ---
z1_correct_est <- sapply(corrected_tabs, function(tab) tab["myz1", "Estimate"])
z1_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz1", "Std. Error"])
z2_correct_est <- sapply(corrected_tabs, function(tab) tab["myz2", "Estimate"])
z2_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz2", "Std. Error"])
# --- Monte Carlo SD (empirical) ---
sd_mc1 <- sd(z1_correct_est, na.rm = TRUE)
sd_mc2 <- sd(z2_correct_est, na.rm = TRUE)
# --- Average model-based SE (Estimated SE, ESE/ASE) ---
mean_se1 <- mean(z1_correct_se, na.rm = TRUE)
mean_se2 <- mean(z2_correct_se, na.rm = TRUE)
# --- Optional direct comparison and ratio ---
cat("\nCorrected z1:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc1))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se1))
cat("\nCorrected z2:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc2))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se2))
library(RegCalReliab)
library(mgcv)
set.seed(123)
# Helper for measurement error
add_err = function(v, sd = sqrt(0.4)) v + rnorm(length(v), 0, sd)
# True slope and OR
beta = log(1.5)
OR_true = 1.5
simulate_once = function() {
# ---- True covariates ----
x = mgcv::rmvn(3000, c(0,0,0),
matrix(c(1,0.3,0.2,
0.3,1,0.5,
0.2,0.5,1), nrow = 3))
# Binary W2 depends on x1
w2 = sapply(x[,1], function(t) {
if (t > median(x[,1])) rbinom(1,1,0.5) else rbinom(1,1,0.3)
})
# Error-free covariates
W = cbind(x[,3], w2)
colnames(W) = c("W1", "W2")
# ---- Replicate design ----
r = c(rep(1,1500), rep(2,500), rep(3,400), rep(4,600))
# Replicates for z1
z1 = rbind(
cbind(add_err(x[1:1500, 1]), NA, NA, NA),
cbind(add_err(x[1501:2000, 1]), add_err(x[1501:2000, 1]), NA, NA),
cbind(add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), NA),
cbind(add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]))
)
colnames(z1) = paste0("z1_",1:4)
# Replicates for z2
z2 = rbind(
cbind(add_err(x[1:1500, 2]), NA, NA, NA),
cbind(add_err(x[1501:2000, 2]), add_err(x[1501:2000, 2]), NA, NA),
cbind(add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), NA),
cbind(add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]))
)
colnames(z2) = paste0("z2_",1:4)
# ---- Poisson outcome ----
# Model: log(E[Y]) = -2.65 + beta*(x1 + x2 + x3) + beta*w2
mu = exp(-2.65 + beta * rowSums(x[,1:3]) + beta * w2)
# Generate counts
Y = rpois(3000, lambda = mu)
# ---- Main data with outcome, replicates, covariates ----
main_data = data.frame(Y, z1, z2, W)
# ---- Regression calibration ----
res = RC_InReliab(
formula   = Y ~ myz1(z1_1, z1_2, z1_3, z1_4) +
myz2(z2_1, z2_2, z2_3, z2_4) +
W1 + W2,
main_data = main_data,
link      = "linear"
)
return(res)
}
B = 10
results_list = replicate(B, simulate_once(), simplify = FALSE)
# Collect naïve + corrected tables
naive_tabs = lapply(results_list, function(x) x$uncorrected)
corrected_tabs = lapply(results_list, function(x) x$corrected)
avg_naive = Reduce("+", naive_tabs) / B
avg_corrected = Reduce("+", corrected_tabs) / B
cat("\nAverage Naive Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_naive, 5))
cat("\nAverage Corrected Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_corrected, 5))
inside_ci = function(tab, i, truth = OR_true) {
ci = tab[i , c("CI.low", "CI.high")]
ci[1] <= truth && truth <= ci[2]
}
row_z1 = which(rownames(avg_naive) == "myz1")
row_z2 = which(rownames(avg_naive) == "myz2")
coverage = function(tab_list, row) {
mean(sapply(tab_list, function(tab) inside_ci(tab, row))) * 100
}
cov_z1_naive = coverage(naive_tabs, row_z1)
cov_z1_corr = coverage(corrected_tabs, row_z1)
cov_z2_naive = coverage(naive_tabs, row_z2)
cov_z2_corr = coverage(corrected_tabs, row_z2)
cat("\nCoverage of OR_true for error-prone exposure z1:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z1_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z1_corr))
cat("\nCoverage of OR_true for error-prone exposure z2:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z2_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z2_corr))
# --- Pull all z1 and z2 estimates and reported SEs (corrected) ---
z1_correct_est <- sapply(corrected_tabs, function(tab) tab["myz1", "Estimate"])
z1_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz1", "Std. Error"])
z2_correct_est <- sapply(corrected_tabs, function(tab) tab["myz2", "Estimate"])
z2_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz2", "Std. Error"])
# --- Monte Carlo SD (empirical) ---
sd_mc1 <- sd(z1_correct_est, na.rm = TRUE)
sd_mc2 <- sd(z2_correct_est, na.rm = TRUE)
# --- Average model-based SE (Estimated SE, ESE/ASE) ---
mean_se1 <- mean(z1_correct_se, na.rm = TRUE)
mean_se2 <- mean(z2_correct_se, na.rm = TRUE)
# --- Optional direct comparison and ratio ---
cat("\nCorrected z1:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc1))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se1))
cat("\nCorrected z2:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc2))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se2))
library(RegCalReliab)
library(mgcv)
set.seed(123)
# Helper for measurement error
add_err = function(v, sd = sqrt(0.4)) v + rnorm(length(v), 0, sd)
# True slope and OR
beta = log(1.5)
OR_true = 1.5
simulate_once = function() {
# ---- True covariates ----
x = mgcv::rmvn(3000, c(0,0,0),
matrix(c(1,0.3,0.2,
0.3,1,0.5,
0.2,0.5,1), nrow = 3))
# Binary W2 depends on x1
w2 = sapply(x[,1], function(t) {
if (t > median(x[,1])) rbinom(1,1,0.5) else rbinom(1,1,0.3)
})
# Error-free covariates
W = cbind(x[,3], w2)
colnames(W) = c("W1", "W2")
# ---- Replicate design ----
r = c(rep(1,1500), rep(2,500), rep(3,400), rep(4,600))
# Replicates for z1
z1 = rbind(
cbind(add_err(x[1:1500, 1]), NA, NA, NA),
cbind(add_err(x[1501:2000, 1]), add_err(x[1501:2000, 1]), NA, NA),
cbind(add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), NA),
cbind(add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]))
)
colnames(z1) = paste0("z1_",1:4)
# Replicates for z2
z2 = rbind(
cbind(add_err(x[1:1500, 2]), NA, NA, NA),
cbind(add_err(x[1501:2000, 2]), add_err(x[1501:2000, 2]), NA, NA),
cbind(add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), NA),
cbind(add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]))
)
colnames(z2) = paste0("z2_",1:4)
# ---- Poisson outcome ----
# Model: log(E[Y]) = -2.65 + beta*(x1 + x2 + x3) + beta*w2
mu = exp(-2.65 + beta * rowSums(x[,1:3]) + beta * w2)
# Generate counts
Y = rpois(3000, lambda = mu)
# ---- Main data with outcome, replicates, covariates ----
main_data = data.frame(Y, z1, z2, W)
# ---- Regression calibration ----
res = RC_InReliab(
formula   = Y ~ myz1(z1_1, z1_2, z1_3, z1_4) +
myz2(z2_1, z2_2, z2_3, z2_4) +
W1 + W2,
main_data = main_data,
link      = "linear"
)
return(res)
}
B = 50
results_list = replicate(B, simulate_once(), simplify = FALSE)
# Collect naïve + corrected tables
naive_tabs = lapply(results_list, function(x) x$uncorrected)
corrected_tabs = lapply(results_list, function(x) x$corrected)
avg_naive = Reduce("+", naive_tabs) / B
avg_corrected = Reduce("+", corrected_tabs) / B
cat("\nAverage Naive Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_naive, 5))
cat("\nAverage Corrected Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_corrected, 5))
inside_ci = function(tab, i, truth = OR_true) {
ci = tab[i , c("CI.low", "CI.high")]
ci[1] <= truth && truth <= ci[2]
}
row_z1 = which(rownames(avg_naive) == "myz1")
row_z2 = which(rownames(avg_naive) == "myz2")
coverage = function(tab_list, row) {
mean(sapply(tab_list, function(tab) inside_ci(tab, row))) * 100
}
cov_z1_naive = coverage(naive_tabs, row_z1)
cov_z1_corr = coverage(corrected_tabs, row_z1)
cov_z2_naive = coverage(naive_tabs, row_z2)
cov_z2_corr = coverage(corrected_tabs, row_z2)
cat("\nCoverage of OR_true for error-prone exposure z1:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z1_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z1_corr))
cat("\nCoverage of OR_true for error-prone exposure z2:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z2_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z2_corr))
# --- Pull all z1 and z2 estimates and reported SEs (corrected) ---
z1_correct_est <- sapply(corrected_tabs, function(tab) tab["myz1", "Estimate"])
z1_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz1", "Std. Error"])
z2_correct_est <- sapply(corrected_tabs, function(tab) tab["myz2", "Estimate"])
z2_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz2", "Std. Error"])
# --- Monte Carlo SD (empirical) ---
sd_mc1 <- sd(z1_correct_est, na.rm = TRUE)
sd_mc2 <- sd(z2_correct_est, na.rm = TRUE)
# --- Average model-based SE (Estimated SE, ESE/ASE) ---
mean_se1 <- mean(z1_correct_se, na.rm = TRUE)
mean_se2 <- mean(z2_correct_se, na.rm = TRUE)
# --- Optional direct comparison and ratio ---
cat("\nCorrected z1:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc1))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se1))
cat("\nCorrected z2:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc2))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se2))
library(RegCalReliab)
library(mgcv)
set.seed(123)
# Helper for measurement error
add_err = function(v, sd = sqrt(0.4)) v + rnorm(length(v), 0, sd)
# True slope and OR
beta = log(1.5)
OR_true = 1.5
simulate_once = function() {
# ---- True covariates ----
x = mgcv::rmvn(3000, c(0,0,0),
matrix(c(1,0.3,0.2,
0.3,1,0.5,
0.2,0.5,1), nrow = 3))
# Binary W2 depends on x1
w2 = sapply(x[,1], function(t) {
if (t > median(x[,1])) rbinom(1,1,0.5) else rbinom(1,1,0.3)
})
# Error-free covariates
W = cbind(x[,3], w2)
colnames(W) = c("W1", "W2")
# ---- Replicate design ----
r = c(rep(1,1500), rep(2,500), rep(3,400), rep(4,600))
# Replicates for z1
z1 = rbind(
cbind(add_err(x[1:1500, 1]), NA, NA, NA),
cbind(add_err(x[1501:2000, 1]), add_err(x[1501:2000, 1]), NA, NA),
cbind(add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), NA),
cbind(add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]))
)
colnames(z1) = paste0("z1_",1:4)
# Replicates for z2
z2 = rbind(
cbind(add_err(x[1:1500, 2]), NA, NA, NA),
cbind(add_err(x[1501:2000, 2]), add_err(x[1501:2000, 2]), NA, NA),
cbind(add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), NA),
cbind(add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]))
)
colnames(z2) = paste0("z2_",1:4)
# ---- Poisson outcome ----
# Model: log(E[Y]) = -2.65 + beta*(x1 + x2 + x3) + beta*w2
mu = exp(-2.65 + beta * rowSums(x[,1:3]) + beta * w2)
# Generate counts
Y = rpois(3000, lambda = mu)
# ---- Main data with outcome, replicates, covariates ----
main_data = data.frame(Y, z1, z2, W)
# ---- Regression calibration ----
res = RC_InReliab(
formula   = Y ~ myz1(z1_1, z1_2, z1_3, z1_4) +
myz2(z2_1, z2_2, z2_3, z2_4) +
W1 + W2,
main_data = main_data,
link      = "linear"
)
return(res)
}
B = 50
results_list = replicate(B, simulate_once(), simplify = FALSE)
# Collect naïve + corrected tables
naive_tabs = lapply(results_list, function(x) x$uncorrected)
corrected_tabs = lapply(results_list, function(x) x$corrected)
avg_naive = Reduce("+", naive_tabs) / B
avg_corrected = Reduce("+", corrected_tabs) / B
cat("\nAverage Naive Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_naive, 5))
cat("\nAverage Corrected Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_corrected, 5))
inside_ci = function(tab, i, truth = OR_true) {
ci = tab[i , c("CI.low", "CI.high")]
ci[1] <= truth && truth <= ci[2]
}
row_z1 = which(rownames(avg_naive) == "myz1")
row_z2 = which(rownames(avg_naive) == "myz2")
coverage = function(tab_list, row) {
mean(sapply(tab_list, function(tab) inside_ci(tab, row))) * 100
}
cov_z1_naive = coverage(naive_tabs, row_z1)
cov_z1_corr = coverage(corrected_tabs, row_z1)
cov_z2_naive = coverage(naive_tabs, row_z2)
cov_z2_corr = coverage(corrected_tabs, row_z2)
cat("\nCoverage of OR_true for error-prone exposure z1:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z1_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z1_corr))
cat("\nCoverage of OR_true for error-prone exposure z2:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z2_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z2_corr))
# --- Pull all z1 and z2 estimates and reported SEs (corrected) ---
z1_correct_est <- sapply(corrected_tabs, function(tab) tab["myz1", "Estimate"])
z1_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz1", "Std. Error"])
z2_correct_est <- sapply(corrected_tabs, function(tab) tab["myz2", "Estimate"])
z2_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz2", "Std. Error"])
# --- Monte Carlo SD (empirical) ---
sd_mc1 <- sd(z1_correct_est, na.rm = TRUE)
sd_mc2 <- sd(z2_correct_est, na.rm = TRUE)
# --- Average model-based SE (Estimated SE, ESE/ASE) ---
mean_se1 <- mean(z1_correct_se, na.rm = TRUE)
mean_se2 <- mean(z2_correct_se, na.rm = TRUE)
# --- Optional direct comparison and ratio ---
cat("\nCorrected z1:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc1))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se1))
cat("\nCorrected z2:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc2))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se2))
library(RegCalReliab)
library(mgcv)
set.seed(123)
# Helper for measurement error
add_err = function(v, sd = sqrt(0.4)) v + rnorm(length(v), 0, sd)
# True slope and OR
beta = log(1.5)
OR_true = 1.5
simulate_once = function() {
# ---- True covariates ----
x = mgcv::rmvn(3000, c(0,0,0),
matrix(c(1,0.3,0.2,
0.3,1,0.5,
0.2,0.5,1), nrow = 3))
# Binary W2 depends on x1
w2 = sapply(x[,1], function(t) {
if (t > median(x[,1])) rbinom(1,1,0.5) else rbinom(1,1,0.3)
})
# Error-free covariates
W = cbind(x[,3], w2)
colnames(W) = c("W1", "W2")
# ---- Replicate design ----
r = c(rep(1,1500), rep(2,500), rep(3,400), rep(4,600))
# Replicates for z1
z1 = rbind(
cbind(add_err(x[1:1500, 1]), NA, NA, NA),
cbind(add_err(x[1501:2000, 1]), add_err(x[1501:2000, 1]), NA, NA),
cbind(add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), NA),
cbind(add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]))
)
colnames(z1) = paste0("z1_",1:4)
# Replicates for z2
z2 = rbind(
cbind(add_err(x[1:1500, 2]), NA, NA, NA),
cbind(add_err(x[1501:2000, 2]), add_err(x[1501:2000, 2]), NA, NA),
cbind(add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), NA),
cbind(add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]))
)
colnames(z2) = paste0("z2_",1:4)
# ---- Poisson outcome ----
# Model: log(E[Y]) = -2.65 + beta*(x1 + x2 + x3) + beta*w2
mu = exp(-2.65 + beta * rowSums(x[,1:3]) + beta * w2)
# Generate counts
Y = rpois(3000, lambda = mu)
# ---- Main data with outcome, replicates, covariates ----
main_data = data.frame(Y, z1, z2, W)
# ---- Regression calibration ----
res = RC_InReliab(
formula   = Y ~ myz1(z1_1, z1_2, z1_3, z1_4) +
myz2(z2_1, z2_2, z2_3, z2_4) +
W1 + W2,
main_data = main_data,
link      = "log"
)
return(res)
}
B = 10
results_list = replicate(B, simulate_once(), simplify = FALSE)
# Collect naïve + corrected tables
naive_tabs = lapply(results_list, function(x) x$uncorrected)
corrected_tabs = lapply(results_list, function(x) x$corrected)
avg_naive = Reduce("+", naive_tabs) / B
avg_corrected = Reduce("+", corrected_tabs) / B
cat("\nAverage Naive Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_naive, 5))
cat("\nAverage Corrected Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_corrected, 5))
inside_ci = function(tab, i, truth = OR_true) {
ci = tab[i , c("CI.low", "CI.high")]
ci[1] <= truth && truth <= ci[2]
}
row_z1 = which(rownames(avg_naive) == "myz1")
row_z2 = which(rownames(avg_naive) == "myz2")
coverage = function(tab_list, row) {
mean(sapply(tab_list, function(tab) inside_ci(tab, row))) * 100
}
cov_z1_naive = coverage(naive_tabs, row_z1)
cov_z1_corr = coverage(corrected_tabs, row_z1)
cov_z2_naive = coverage(naive_tabs, row_z2)
cov_z2_corr = coverage(corrected_tabs, row_z2)
cat("\nCoverage of OR_true for error-prone exposure z1:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z1_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z1_corr))
cat("\nCoverage of OR_true for error-prone exposure z2:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z2_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z2_corr))
# --- Pull all z1 and z2 estimates and reported SEs (corrected) ---
z1_correct_est <- sapply(corrected_tabs, function(tab) tab["myz1", "Estimate"])
z1_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz1", "Std. Error"])
z2_correct_est <- sapply(corrected_tabs, function(tab) tab["myz2", "Estimate"])
z2_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz2", "Std. Error"])
# --- Monte Carlo SD (empirical) ---
sd_mc1 <- sd(z1_correct_est, na.rm = TRUE)
sd_mc2 <- sd(z2_correct_est, na.rm = TRUE)
# --- Average model-based SE (Estimated SE, ESE/ASE) ---
mean_se1 <- mean(z1_correct_se, na.rm = TRUE)
mean_se2 <- mean(z2_correct_se, na.rm = TRUE)
# --- Optional direct comparison and ratio ---
cat("\nCorrected z1:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc1))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se1))
cat("\nCorrected z2:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc2))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se2))
