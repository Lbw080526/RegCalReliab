corrected.point.sbp<- coef/rho1["sbp"]
print(round(exp(inc*corrected.point.sbp),round.num))
corrected.point.sbp<- coef/auto.icc["sbp","sbp"]
source("RC_EX_Logistic_2025.R")
fit_new = RC_EX_logistic(
formula   = comb ~ sbp(sbp2, sbp3) + chol(chol2, chol3) + gluc(gluc2, gluc3) +
bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link      = "logistic",
return_details = TRUE   # get ICC and other internals
)
auto.icc = fit_new$details$rc$icc[1:3, 1:3])
source("RC_EX_Logistic_2025.R")
fit_new = RC_EX_logistic(
formula   = comb ~ sbp(sbp2, sbp3) + chol(chol2, chol3) + gluc(gluc2, gluc3) +
bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link      = "logistic",
return_details = TRUE   # get ICC and other internals
)
auto.icc = fit_new$details$rc$icc([1:3, 1:3])
source("RC_EX_Logistic_2025.R")
fit_new = RC_EX_logistic(
formula   = comb ~ sbp(sbp2, sbp3) + chol(chol2, chol3) + gluc(gluc2, gluc3) +
bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link      = "logistic",
return_details = TRUE   # get ICC and other internals
)
auto_icc = fit_new$details$rc$icc[1:3, 1:3]
print(auto_icc)
uncorrected.fit<-glm(data=ms, formula= comb ~ sbp, family=binomial(link="logit"))
coef<- coef(uncorrected.fit)[2]
sd<- sqrt(diag(vcov(uncorrected.fit))[2])
inc=49
round.num=3
OR=round(exp(inc*coef),round.num)
ORlwr=round(exp(inc*(coef-1.96*sd)),round.num)
ORupr=round(exp(inc*(coef+1.96*sd)),round.num)
print(paste(OR, "(" ,ORlwr, ",",ORupr ,")"))
corrected.point.sbp<- coef/rho1["sbp"]
print(round(exp(inc*corrected.point.sbp),round.num))
corrected.point.sbp<- coef/auto.icc["sbp","sbp"]
source("RC_EX_Logistic_2025.R")
fit_new = RC_EX_logistic(
formula   = comb ~ sbp(sbp2, sbp3) + chol(chol2, chol3) + gluc(gluc2, gluc3) +
bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link      = "logistic",
return_details = TRUE   # get ICC and other internals
)
auto.icc = fit_new$details$rc$icc[1:3, 1:3]
print(auto.icc)
uncorrected.fit<-glm(data=ms, formula= comb ~ sbp, family=binomial(link="logit"))
coef<- coef(uncorrected.fit)[2]
sd<- sqrt(diag(vcov(uncorrected.fit))[2])
inc=49
round.num=3
OR=round(exp(inc*coef),round.num)
ORlwr=round(exp(inc*(coef-1.96*sd)),round.num)
ORupr=round(exp(inc*(coef+1.96*sd)),round.num)
print(paste(OR, "(" ,ORlwr, ",",ORupr ,")"))
corrected.point.sbp<- coef/rho1["sbp"]
print(round(exp(inc*corrected.point.sbp),round.num))
corrected.point.sbp<- coef/auto.icc["sbp","sbp"]
print(round(exp(inc*corrected.point.sbp),round.num))
fit_new <- RC_EX_logistic(
formula = comb ~ sbp(sbp2, sbp3) + chol + gluc + bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link      = "logistic",
return_details = TRUE
)
fit_new <- RC_EX_logistic(
formula = comb ~ sbp(sbp2, sbp3) + chol + gluc + bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link      = "logistic",
return_details = TRUE
)
fit_new$corrected
## --- 1. Fit corrected logistic regression with your new code ---
fit_new <- RC_EX_logistic(
formula = comb ~ sbp(sbp2, sbp3) + chol + gluc + bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link = "logistic",
return_details = TRUE
)
## --- 2. Pull the corrected sbp coefficient and its sandwich SE ---
# 2nd row = sbp (1st row is intercept)
coef <- fit_new$corrected[2, 1]
sd   <- fit_new$corrected[2, 2]
## --- 3. Compute odds ratio for a 49-unit increase (with CI) ---
inc <- 49
round.num <- 3
OR     <- round(exp(inc * coef), round.num)
ORlwr  <- round(exp(inc * (coef - 1.96 * sd)), round.num)
ORupr  <- round(exp(inc * (coef + 1.96 * sd)), round.num)
print(paste(OR, "(", ORlwr, ",", ORupr, ")"))
## --- 4. Small-measurement-error check ---
icc        <- fit_new$details$rc$icc[1, 1]                      # reliability coefficient
sigma2_X   <- fit_new$details$rc$sigmax[1, 1]                   # between-person variance
siamg2_X_Z <- sigma2_X * (1 - icc)                              # error variance
me.value   <- siamg2_X_Z * coef^2                               # small-measurement-error value
print(paste("Small measurement value is:", round(me.value, round.num)))
## --- 1. Fit corrected logistic regression with your new code ---
fit_new <- RC_EX_logistic(
formula = comb ~ sbp(sbp2, sbp3) + chol + gluc + bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link = "logistic",
return_details = TRUE
)
## --- 2. Pull the corrected sbp coefficient and its sandwich SE ---
# 2nd row = sbp (1st row is intercept)
coef <- fit_new$corrected[2, 1]
sd   <- fit_new$corrected[2, 2]
## --- 3. Compute odds ratio for a 49-unit increase (with CI) ---
inc <- 49
round.num <- 10
OR     <- round(exp(inc * coef), round.num)
ORlwr  <- round(exp(inc * (coef - 1.96 * sd)), round.num)
ORupr  <- round(exp(inc * (coef + 1.96 * sd)), round.num)
print(paste(OR, "(", ORlwr, ",", ORupr, ")"))
## --- 4. Small-measurement-error check ---
icc        <- fit_new$details$rc$icc[1, 1]                      # reliability coefficient
sigma2_X   <- fit_new$details$rc$sigmax[1, 1]                   # between-person variance
siamg2_X_Z <- sigma2_X * (1 - icc)                              # error variance
me.value   <- siamg2_X_Z * coef^2                               # small-measurement-error value
print(paste("Small measurement value is:", round(me.value, round.num)))
## --- 1. Fit corrected logistic regression with your new code ---
fit_new <- RC_EX_logistic(
formula = comb ~ sbp(sbp2, sbp3) + chol + gluc + bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link = "logistic",
return_details = TRUE
)
## --- 2. Pull the corrected sbp coefficient and its sandwich SE ---
# 2nd row = sbp (1st row is intercept)
coef <- fit_new$corrected[2, 1]
sd   <- fit_new$corrected[2, 2]
## --- 3. Compute odds ratio for a 49-unit increase (with CI) ---
inc <- 49
round.num <- 5
OR     <- round(exp(inc * coef), round.num)
ORlwr  <- round(exp(inc * (coef - 1.96 * sd)), round.num)
ORupr  <- round(exp(inc * (coef + 1.96 * sd)), round.num)
print(paste(OR, "(", ORlwr, ",", ORupr, ")"))
## --- 4. Small-measurement-error check ---
icc        <- fit_new$details$rc$icc[1, 1]                      # reliability coefficient
sigma2_X   <- fit_new$details$rc$sigmax[1, 1]                   # between-person variance
siamg2_X_Z <- sigma2_X * (1 - icc)                              # error variance
me.value   <- siamg2_X_Z * coef^2                               # small-measurement-error value
print(paste("Small measurement value is:", round(me.value, round.num)))
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, tidy.opts=list(width.cutoff=90), tidy=TRUE)
library(tidyverse)
library(gmodels)
main = read.table("main_2025 (1).dat", header=FALSE, sep=" ")
setwd("~/Desktop/EPI515_BOWEN_REVISED/testhw")
main = read.table("main_2025 (1).dat", header=FALSE, sep=" ")
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, tidy.opts=list(width.cutoff=90), tidy=TRUE)
library(tidyverse)
library(gmodels)
main = read.table("main_2025 (1).dat", header=FALSE, sep=" ")
main = read.table("'/Users/liubowen/Desktop/EPI515_BOWEN_REVISED/testhw/data/main_2025 (1).dat'", header=FALSE, sep=" ")
main = read.table("/Users/liubowen/Desktop/EPI515_BOWEN_REVISED/testhw/data/main_2025 (1).dat", header=FALSE, sep=" ")
colnames(main) = c("id","caseall","Z")
vali = read.table("validation (2).dat", header=FALSE, sep=" ")
main = read.table("/Users/liubowen/Desktop/EPI515_BOWEN_REVISED/testhw/data/main_2025 (1).dat", header=FALSE, sep=" ")
colnames(main) = c("id","caseall","Z")
vali = read.table("'/Users/liubowen/Desktop/EPI515_BOWEN_REVISED/testhw/data/validation (2).dat'", header=FALSE, sep=" ")
View(main)
setwd("~/Desktop/EPI515_BOWEN_REVISED/hw2")
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, tidy.opts=list(width.cutoff=90), tidy=TRUE)
library(tidyverse)
library(irr)
library(dplyr)
library(MASS)
library(lmtest)
library(sandwich)
ms <- read.table("ms_2025.csv",header=TRUE,sep=",")
vs <- read.table("vs.csv",header=TRUE,sep=",")
cor(vs$Z_cont,vs$X_cont)
## assessing assumptions
### Criteria 1: linearity assumption
#### outcome model
source("testLinear.R")
test1<-testLinear(ds=ms,outcome="case",var="Z_cont",nknots=5,
method="glm",family=binomial,link="logit",densplot=TRUE)
# test1<-testLinear(ds=ms,outcome="case",var="Z_cont",adj=c("age"),nknots=5,
#                   method="glm",family=binomial,link="logit",densplot=TRUE)
test1$testOfLinearity
test1$fittedCBSplineCurve # very linear
#### validation model
test2<-testLinear(ds=vs,outcome="X_cont",var="Z_cont",nknots=5,
method="lm",densplot=TRUE)
# test2<-testLinear(ds=vs,outcome="X_cont",var="Z_cont",nknots=5,
#                   method="lm",densplot=TRUE)
test2$testOfLinearity # significant non-linearity, but mostly caused by value Z_cont >10
test2$fittedCBSplineCurve
### Criteria 2.1: rare D + normal and homoscedastic error
#### rare disease assumption
prop.table(table(ms$case)) # yes, rare disease
#### homoskedastic and nomral  error in measurement error model
lm.me.model<-lm(data=vs, formula= X_cont ~ Z_cont + age)
# graphical
par(mfrow=c(2,2))
plot(lm.me.model) # substantial heteroskedascity and non-normality (from QQ plot), visually
# Breush-Pagan test of homoskedasticity
lmtest::bptest(lm.me.model) # strong heteroskedasticity
### Criteria 2.2: small ME
# residuals squares mean
source("regCalibRSW.R")
sigma2_X_Z<-sqrt(mean((lm.me.model$residuals)^2))
# corrected point estimate
rsw.result<-regCalibRSW(supplyEstimates=FALSE, ms=ms,vs=vs,
sur="Z_cont", exp="X_cont", covCalib="age", covOutcome=NULL, outcome="case",
method="glm",family=binomial,link="logit", external=TRUE,
pointEstimates=NA, vcovEstimates=NA) # true effect= 0.05
betaTrue<-rsw.result$correctedCoefTable[1]
(sigma2_X_Z*betaTrue)^2# sigma(X|Z)*beta = 0.1 --> small measurement error
## RSW method
# unadjusted
rsw.result.unadjusted<-regCalibRSW(supplyEstimates=FALSE, ms=ms,vs=vs,
sur="Z_cont", exp="X_cont", covCalib=NULL, covOutcome=NULL, outcome="case",
method="glm",family=binomial,link="logit", external=TRUE,
pointEstimates=NA, vcovEstimates=NA) # true effect= 0.05
# corrected
coef<-rsw.result.unadjusted$correctedCoefTable[,1]
sd<-rsw.result.unadjusted$correctedCoefTable[,2]
rsw.result.unadjusted.result<-round(exp(cbind(coef*3,3*(coef-1.96*sd),3*(coef+1.96*sd))),4)
# uncorrected
coef<-rsw.result.unadjusted$standardCoefTable[1]
sd<-rsw.result.unadjusted$standardCoefTable[2]
result.unadjusted.uncorrected<-round(exp(cbind(coef*3,3*(coef-1.96*sd),3*(coef+1.96*sd))),4)
# adjusted
rsw.result.adjusted<-regCalibRSW(supplyEstimates=FALSE, ms=ms,vs=vs,
sur="Z_cont", exp="X_cont", covCalib="age", covOutcome=NULL, outcome="case",
method="glm",family=binomial,link="logit", external=TRUE,
pointEstimates=NA, vcovEstimates=NA) # true effect= 0.05
#corrected
coef<-rsw.result.adjusted$correctedCoefTable[,1]
sd<-rsw.result.adjusted$correctedCoefTable[,2]
rsw.result.adjusted.result<-round(exp(cbind(coef*3,3*(coef-1.96*sd),3*(coef+1.96*sd))),4)
# uncorrected
coef<-rsw.result.adjusted$standardCoefTable[1,1]
sd<-rsw.result.adjusted$standardCoefTable[1,2]
result.adjusted.uncorrected<-round(exp(cbind(coef*3,3*(coef-1.96*sd),3*(coef+1.96*sd))),4)
## CRS method
# unadjusted
## measurement error model
lm.me.model1<-lm(data=vs, formula= X_cont ~ Z_cont)
main1<-cbind(pred.X_cont=predict(object=lm.me.model1,newdata=ms),ms)%>%as.data.frame()
## outcome model
lm.o.model1<-glm(data=main1,formula= case ~ pred.X_cont,family=binomial(link="logit"))
coef<- coef(lm.o.model1)
sd<- sqrt(diag(vcov(lm.o.model1)))
# sd<- sqrt(diag(vcovHC(lm.o.model1,type="HC3")))
crs.result.unadjusted.result<-round(exp(cbind(coef*3,3*(coef-1.96*sd),3*(coef+1.96*sd))),4)
# adjusted
## measurement error model
lm.me.model2<-lm(data=vs, formula= X_cont ~ Z_cont + age)
main2<-cbind(pred.X_cont=predict(object=lm.me.model2,newdata=ms),ms)%>%as.data.frame()
## outcome model
lm.o.model2<-glm(data=main2,formula= case ~ pred.X_cont + age,family=binomial(link="logit"))
coef<- coef(lm.o.model2)
sd<- sqrt(diag(vcov(lm.o.model2)))
# sd<- sqrt(diag(vcovHC(lm.o.model1,type="HC3")))
crs.result.adjusted.result<-round(exp(cbind(coef*3,3*(coef-1.96*sd),3*(coef+1.96*sd))),4)
## summary
resultsAll<-rbind(result.unadjusted.uncorrected, result.adjusted.uncorrected, rsw.result.unadjusted.result,rsw.result.adjusted.result[1,],crs.result.unadjusted.result[2,],crs.result.adjusted.result[2,])
colnames(resultsAll)<-c("OR","95CI lwr","95CI upr")
rownames(resultsAll)<-c("unadjusted, uncorrected","adjusted, uncorrected","unadjusted, Rosner","adjusted, Rosner","unadjusted CRS","adjusted, CRS")
print(resultsAll)
ms <- read.table("frm_ms_2025.csv", header=TRUE, sep=",")
rs <- read.table("frm_rs_2025.csv", header=TRUE, sep=",")
library(irr)
rs%>%dplyr::select(sbp2,sbp3)%>%icc()
rs%>%dplyr::select(chol2,chol3)%>%icc()
rs%>%dplyr::select(gluc2,gluc3)%>%icc()
# we calculate the ICC ourselves
## main study: sigma^2_Z
sigma2_Z<-apply(ms%>%dplyr::select(sbp, chol, gluc),2,var)
## reliability study
nri=2
nr= nrow(rs)
callSigma2<-function(x){
nri= ncol(x)
nr= nrow(x)
Z_i_bar= apply(x,1,mean)
mat<-cbind(as.matrix(x),matrix(NA,ncol=nri,nrow=nr))
# print(Z_i_bar)
for(i in 1:nri){
mat[,i+nri]<-(mat[,i]-Z_i_bar)^2
}
# print(mat)
output<-sum(mat[,(nri+1):(2*nri)])/(nr*(nri-1))
return(output)
}
sigma2<-c(callSigma2(rs%>%dplyr::select(sbp2,sbp3)),
callSigma2(rs%>%dplyr::select(chol2,chol3)),
callSigma2(rs%>%dplyr::select(gluc2,gluc3))
)
sigma2_X<-sigma2_Z-sigma2
rho1<-sigma2_X/sigma2_Z
print(rho1)
source("RC_EX_Logistic_2025.R")
fit_new = RC_EX_logistic(
formula   = comb ~ sbp(sbp2, sbp3) + chol(chol2, chol3) + gluc(gluc2, gluc3) +
bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link      = "logistic",
return_details = TRUE   # get ICC and other internals
)
auto.icc = fit_new$details$rc$icc[1:3, 1:3]
print(auto.icc)
uncorrected.fit<-glm(data=ms, formula= comb ~ sbp, family=binomial(link="logit"))
coef<- coef(uncorrected.fit)[2]
sd<- sqrt(diag(vcov(uncorrected.fit))[2])
inc=49
round.num=3
OR=round(exp(inc*coef),round.num)
ORlwr=round(exp(inc*(coef-1.96*sd)),round.num)
ORupr=round(exp(inc*(coef+1.96*sd)),round.num)
print(paste(OR, "(" ,ORlwr, ",",ORupr ,")"))
corrected.point.sbp<- coef/rho1["sbp"]
print(round(exp(inc*corrected.point.sbp),round.num))
corrected.point.sbp<- coef/auto.icc["sbp","sbp"]
print(round(exp(inc*corrected.point.sbp),round.num))
## --- 1. Fit corrected logistic regression with your new code ---
fit_new <- RC_EX_logistic(
formula = comb ~ sbp(sbp2, sbp3) + chol + gluc + bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link = "logistic",
return_details = TRUE
)
## --- 2. Pull the corrected sbp coefficient and its sandwich SE ---
# 2nd row = sbp (1st row is intercept)
coef <- fit_new$corrected[2, 1]
sd   <- fit_new$corrected[2, 2]
## --- 3. Compute odds ratio for a 49-unit increase (with CI) ---
inc <- 49
round.num <- 5
OR     <- round(exp(inc * coef), round.num)
ORlwr  <- round(exp(inc * (coef - 1.96 * sd)), round.num)
ORupr  <- round(exp(inc * (coef + 1.96 * sd)), round.num)
print(paste(OR, "(", ORlwr, ",", ORupr, ")"))
## --- 4. Small-measurement-error check ---
icc        <- fit_new$details$rc$icc[1, 1]                      # reliability coefficient
sigma2_X   <- fit_new$details$rc$sigmax[1, 1]                   # between-person variance
siamg2_X_Z <- sigma2_X * (1 - icc)                              # error variance
me.value   <- siamg2_X_Z * coef^2                               # small-measurement-error value
print(paste("Small measurement value is:", round(me.value, round.num)))
fit_new$corrected
## --- 1. Fit corrected logistic regression with your new code ---
fit_new <- RC_EX_logistic(
formula = comb ~ sbp(sbp2, sbp3) + chol + gluc + bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link = "logistic",
return_details = TRUE
)
# Find the row corresponding to sbp (xhat) explicitly
sbp_row <- grep("^sbp$|^xhat", rownames(fit_new$corrected), value = TRUE)
coef <- fit_new$corrected[sbp_row, "Estimate"]
sd   <- fit_new$corrected[sbp_row, "Std. Error"]
# Reliability (ICC) for sbp
icc <- fit_new$details$rc$icc["sbp", "sbp"]
## --- 1. Fit corrected logistic regression with your new code ---
fit_new <- RC_EX_logistic(
formula = comb ~ sbp(sbp2, sbp3) + chol + gluc + bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link = "logistic",
return_details = TRUE
)
## --- 2. Pull the corrected sbp coefficient and its sandwich SE ---
# 2nd row = sbp (1st row is intercept)
coef <- fit_new$corrected[2, 1]
sd   <- fit_new$corrected[2, 2]
## --- 3. Compute odds ratio for a 49-unit increase (with CI) ---
inc <- 49
round.num <- 5
OR     <- round(exp(inc * coef), round.num)
ORlwr  <- round(exp(inc * (coef - 1.96 * sd)), round.num)
ORupr  <- round(exp(inc * (coef + 1.96 * sd)), round.num)
print(paste(OR, "(", ORlwr, ",", ORupr, ")"))
# Find the row corresponding to sbp (xhat) explicitly
sbp_row <- grep("^sbp$|^xhat", rownames(fit_new$corrected), value = TRUE)
coef <- fit_new$corrected[sbp_row, "Estimate"]
sd   <- fit_new$corrected[sbp_row, "Std. Error"]
# Reliability (ICC) for sbp
icc <- fit_new$details$rc$icc["sbp", "sbp"]
rownames(fit_new$details$rc$icc)  # to check the names
## ==========================================================
##  Corrected Logistic Regression with Small-Error Check
##  using RC_EX_logistic()  — single exposure (sbp)
## ==========================================================
## 1. Fit corrected logistic regression
fit_new <- RC_EX_logistic(
formula = comb ~ sbp(sbp2, sbp3) + chol + gluc + bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link      = "logistic",
return_details = TRUE
)
## 2. Extract sbp coefficient and robust (sandwich) SE
# sbp is the 2nd row (first is intercept)
coef <- fit_new$corrected[2, "Estimate"]
sd   <- fit_new$corrected[2, "Std. Error"]
## 3. Compute odds ratio for a 49-unit increase with 95% CI
inc       <- 49
round.num <- 5
OR    <- round(exp(inc * coef), round.num)
ORlwr <- round(exp(inc * (coef - 1.96 * sd)), round.num)
ORupr <- round(exp(inc * (coef + 1.96 * sd)), round.num)
cat("Odds ratio for", inc, "unit increase in sbp:",
OR, "(", ORlwr, ",", ORupr, ")\n")
## 4. Small-measurement-error calculation
# sbp is the first row/column but has an empty name in icc and sigmax
icc       <- fit_new$details$rc$icc[1, 1]
sigma2_X  <- fit_new$details$rc$sigmax[1, 1]
siamg2_X_Z <- sigma2_X * (1 - icc)         # error variance
me.value   <- siamg2_X_Z * coef^2          # small-measurement-error value
cat("Small measurement value is:", round(me.value, round.num), "\n")
## Optional: look at the full corrected coefficient table
print(fit_new$corrected)
## --- 1. Fit corrected logistic regression with your new code ---
fit_new <- RC_EX_logistic(
formula = comb ~ sbp(sbp2, sbp3) + chol + gluc + bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link = "logistic",
return_details = TRUE
)
## --- 2. Pull the corrected sbp coefficient and its sandwich SE ---
# 2nd row = sbp (1st row is intercept)
coef <- fit_new$corrected[2, 1]
sd   <- fit_new$corrected[2, 2]
## --- 3. Compute odds ratio for a 49-unit increase (with CI) ---
inc <- 49
round.num <- 5
OR     <- round(exp(inc * coef), round.num)
ORlwr  <- round(exp(inc * (coef - 1.96 * sd)), round.num)
ORupr  <- round(exp(inc * (coef + 1.96 * sd)), round.num)
print(paste(OR, "(", ORlwr, ",", ORupr, ")"))
## --- 4. Small-measurement-error check ---
icc        <- fit_new$details$rc$icc[1, 1]                      # reliability coefficient
sigma2_X   <- fit_new$details$rc$sigmax[1, 1]                   # between-person variance
siamg2_X_Z <- sigma2_X * (1 - icc)                              # error variance
me.value   <- siamg2_X_Z * coef^2                               # small-measurement-error value
print(paste("Small measurement value is:", round(me.value, round.num)))
## ==========================================================
##  Corrected Logistic Regression with Three Exposures
##  using RC_EX_logistic()  — replacement for RC.ex()
## ==========================================================
## 1. Fit corrected logistic regression
fit_new <- RC_EX_logistic(
formula = comb ~ sbp(sbp2, sbp3) + chol(chol2, chol3) + gluc(gluc2, gluc3) +
bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link = "logistic",
return_details = TRUE
)
## 2. Pull the corrected coefficient and SE for sbp
# In the corrected table the second row is sbp (first is intercept)
coef <- fit_new$corrected[2, "Estimate"]
sd   <- fit_new$corrected[2, "Std. Error"]
## 3. Compute odds ratio for a 49-unit increase in sbp
inc       <- 49
round.num <- 3
OR    <- round(exp(inc * coef), round.num)
ORlwr <- round(exp(inc * (coef - 1.96 * sd)), round.num)
ORupr <- round(exp(inc * (coef + 1.96 * sd)), round.num)
cat("Odds ratio for", inc, "unit increase in sbp:",
OR, "(", ORlwr, ",", ORupr, ")\n")
## 4. (Optional) Inspect the full corrected coefficient table
print(fit_new$corrected)
## ==========================================================
##  Corrected Logistic Regression with Three Exposures
##  using RC_EX_logistic()  — replacement for RC.ex()
## ==========================================================
## 1. Fit corrected logistic regression
fit_new <- RC_EX_logistic(
formula = comb ~ sbp(sbp2, sbp3) + chol(chol2, chol3) + gluc(gluc2, gluc3) +
bmi + smoke + age2 + age3 + age4,
main_data = ms,
rep_data  = rs,
link = "logistic",
return_details = TRUE
)
## 2. Pull the corrected coefficient and SE for sbp
# In the corrected table the second row is sbp (first is intercept)
coef <- fit_new$corrected[2, "Estimate"]
sd   <- fit_new$corrected[2, "Std. Error"]
## 3. Compute odds ratio for a 49-unit increase in sbp
inc       <- 49
round.num <- 3
OR    <- round(exp(inc * coef), round.num)
ORlwr <- round(exp(inc * (coef - 1.96 * sd)), round.num)
ORupr <- round(exp(inc * (coef + 1.96 * sd)), round.num)
cat("Odds ratio for", inc, "unit increase in sbp:",
OR, "(", ORlwr, ",", ORupr, ")\n")
