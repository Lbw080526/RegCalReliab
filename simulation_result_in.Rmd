---
title: "simulation_result_in"
output: html_document
date: "2025-09-24"
---

```{r}
library(RegCalReliab)
library(mgcv)
set.seed(123)

# Helper for measurement error
add_err = function(v, sd = sqrt(0.4)) v + rnorm(length(v), 0, sd)

# True slope and OR
beta = log(1.5)
OR_true = 1.5

simulate_once = function() {
  # ---- True covariates ----
  x = mgcv::rmvn(3000, c(0,0,0),
                  matrix(c(1,0.3,0.2,
                           0.3,1,0.5,
                           0.2,0.5,1), nrow = 3))
  
  # Binary W2 depends on x1
  w2 = sapply(x[,1], function(t) {
    if (t > median(x[,1])) rbinom(1,1,0.5) else rbinom(1,1,0.3)
  })
  
  # Error-free covariates
  W = cbind(x[,3], w2)
  colnames(W) = c("W1", "W2")
  
  # ---- Replicate design ----
  r = c(rep(1,1500), rep(2,500), rep(3,400), rep(4,600))
  
  # Replicates for z1
  z1 = rbind(
    cbind(add_err(x[1:1500, 1]), NA, NA, NA),
    cbind(add_err(x[1501:2000, 1]), add_err(x[1501:2000, 1]), NA, NA),
    cbind(add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), NA),
    cbind(add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]))
  )
  colnames(z1) = paste0("z1_",1:4)
  
  # Replicates for z2
  z2 = rbind(
    cbind(add_err(x[1:1500, 2]), NA, NA, NA),
    cbind(add_err(x[1501:2000, 2]), add_err(x[1501:2000, 2]), NA, NA),
    cbind(add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), NA),
    cbind(add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]))
  )
  colnames(z2) = paste0("z2_",1:4)
  
  # ---- Outcome ----
  p = plogis(-2.65 + beta*rowSums(x[,1:3]) + beta*w2)
  Y = rbinom(3000, 1, p)
  
  # ---- Main data with outcome, replicates, covariates ----
  main_data = data.frame(Y, z1, z2, W)
  
  # ---- Regression calibration ----
  res = RC_InReliab(
    formula   = Y ~ myz1(z1_1, z1_2, z1_3, z1_4) +
                  myz2(z2_1, z2_2, z2_3, z2_4) +
                  W1 + W2,
    main_data = main_data,
    link      = "logistic"
  )
  
  return(res)
}

B = 1000
results_list = replicate(B, simulate_once(), simplify = FALSE)

# Collect naïve + corrected tables
naive_tabs = lapply(results_list, function(x) x$uncorrected)
corrected_tabs = lapply(results_list, function(x) x$corrected)

avg_naive = Reduce("+", naive_tabs) / B
avg_corrected = Reduce("+", corrected_tabs) / B

cat("\nAverage Naive Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_naive, 5))

cat("\nAverage Corrected Logistic Estimates (B = ", B, "):\n", sep = "")
print(round(avg_corrected, 5))

inside_ci = function(tab, i, truth = OR_true) {
  ci = tab[i , c("CI.low", "CI.high")]
  ci[1] <= truth && truth <= ci[2]
}

row_z1 = which(rownames(avg_naive) == "myz1")
row_z2 = which(rownames(avg_naive) == "myz2")

coverage = function(tab_list, row) {
  mean(sapply(tab_list, function(tab) inside_ci(tab, row))) * 100
}

cov_z1_naive = coverage(naive_tabs, row_z1)
cov_z1_corr = coverage(corrected_tabs, row_z1)
cov_z2_naive = coverage(naive_tabs, row_z2)
cov_z2_corr = coverage(corrected_tabs, row_z2)

cat("\nCoverage of TRUE OR = 1.5 for error-prone exposure z1:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z1_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z1_corr))

cat("\nCoverage of TRUE OR = 1.5 for error-prone exposure z2:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z2_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z2_corr))


# --- Pull all z1 and z2 estimates and reported SEs (corrected) ---
z1_correct_est <- sapply(corrected_tabs, function(tab) tab["myz1", "Estimate"])
z1_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz1", "Std. Error"])
z2_correct_est <- sapply(corrected_tabs, function(tab) tab["myz2", "Estimate"])
z2_correct_se  <- sapply(corrected_tabs, function(tab) tab["myz2", "Std. Error"])

# --- Monte Carlo SD (empirical) ---
sd_mc1 <- sd(z1_correct_est, na.rm = TRUE)
sd_mc2 <- sd(z2_correct_est, na.rm = TRUE)

# --- Average model-based SE (Estimated SE, ESE/ASE) ---
mean_se1 <- mean(z1_correct_se, na.rm = TRUE)
mean_se2 <- mean(z2_correct_se, na.rm = TRUE)

# --- Optional direct comparison and ratio ---
cat("\nCorrected z1:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc1))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se1))

cat("\nCorrected z2:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc2))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se2))
```


```{r}
# INTERNAL 1Z 0W
library(RegCalReliab)
library(mgcv)
set.seed(123)

# --- Helper to add classical measurement error
add_err <- function(v, sd = sqrt(0.4)) v + rnorm(length(v), 0, sd)

# --- True slope and OR
beta <- log(1.5)
OR_true <- 1.5

simulate_once <- function() {
  ## ---- True exposure ----
  x <- rnorm(3000)
  
  ## ---- Replicate design: 1, 2, 3, 4 replicates
  r <- c(rep(1,1500), rep(2,500), rep(3,400), rep(4,600))
  
  ## ---- Replicates for z ----
  z <- rbind(
    cbind(add_err(x[1:1500]), NA, NA, NA),
    cbind(add_err(x[1501:2000]), add_err(x[1501:2000]), NA, NA),
    cbind(add_err(x[2001:2400]), add_err(x[2001:2400]), add_err(x[2001:2400]), NA),
    cbind(add_err(x[2401:3000]), add_err(x[2401:3000]), add_err(x[2401:3000]), add_err(x[2401:3000]))
  )
  colnames(z) <- paste0("z_", 1:4)
  
  ## ---- Outcome ----
  p <- plogis(-2.65 + beta * x)
  Y <- rbinom(3000, 1, p)
  
  ## ---- Main data with outcome and replicates only ----
  main_data <- data.frame(Y, z)
  
  ## ---- Regression calibration (internal reliability) ----
  RC_InReliab(
    formula   = Y ~ myz(z_1, z_2, z_3, z_4),
    main_data = main_data,
    link      = "logistic"
  )
}

## ---- Monte Carlo loop ----
B <- 1000
results_list <- replicate(B, simulate_once(), simplify = FALSE)

## ---- Extract naïve and corrected tables
naive_tabs     <- lapply(results_list, function(x) x$uncorrected)
corrected_tabs <- lapply(results_list, function(x) x$corrected)

avg_naive     <- Reduce("+", naive_tabs) / B
avg_corrected <- Reduce("+", corrected_tabs) / B

cat("\nAverage Naive Logistic Estimates (B=", B, "):\n", sep = "")
print(round(avg_naive, 5))

cat("\nAverage Corrected Logistic Estimates (B=", B, "):\n", sep = "")
print(round(avg_corrected, 5))

## ---- Coverage of TRUE OR = 1.5 ----
inside_ci <- function(tab, i, truth = OR_true) {
  ci <- tab[i, c("CI.low", "CI.high")]
  truth >= ci[1] && truth <= ci[2]
}

row_z <- 2


coverage <- function(tab_list, row) {
  mean(sapply(tab_list, function(tab) inside_ci(tab, row))) * 100
}

cov_z_naive <- coverage(naive_tabs, row_z)
cov_z_corr  <- coverage(corrected_tabs, row_z)

cat("\nCoverage of TRUE OR = 1.5 for error-prone exposure z:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z_corr))

## ---- Monte Carlo SD vs mean reported SE ----
z_correct_est <- sapply(corrected_tabs, function(tab) tab[2, "Estimate"])
z_correct_se  <- sapply(corrected_tabs, function(tab) tab[2, "Std. Error"])

sd_mc   <- sd(z_correct_est, na.rm = TRUE)
mean_se <- mean(z_correct_se, na.rm = TRUE)

cat("\nCorrected z:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se))

```
```{r}
# INTERNAL 1Z 1W
library(RegCalReliab)
library(mgcv)
set.seed(123)

# --- Helper to add classical measurement error
add_err <- function(v, sd = sqrt(0.4)) v + rnorm(length(v), 0, sd)

# --- True slope and OR
beta <- log(1.5)
OR_true <- 1.5

simulate_once <- function() {
  ## ---- True exposure and covariate ----
  x  <- rnorm(3000)         # true exposure
  W1 <- rnorm(3000)         # error-free covariate
  
  ## ---- Replicate design: 1, 2, 3, 4 replicates
  r <- c(rep(1,1500), rep(2,500), rep(3,400), rep(4,600))
  
  ## ---- Replicates for z ----
  z <- rbind(
    cbind(add_err(x[1:1500]), NA, NA, NA),
    cbind(add_err(x[1501:2000]), add_err(x[1501:2000]), NA, NA),
    cbind(add_err(x[2001:2400]), add_err(x[2001:2400]), add_err(x[2001:2400]), NA),
    cbind(add_err(x[2401:3000]), add_err(x[2401:3000]), add_err(x[2401:3000]), add_err(x[2401:3000]))
  )
  colnames(z) <- paste0("z_", 1:4)
  
  ## ---- Outcome ----
  p <- plogis(-2.65 + beta * x + 0.5 * W1)
  Y <- rbinom(3000, 1, p)
  
  ## ---- Main data with outcome, replicates, and W ----
  main_data <- data.frame(Y, z, W1)
  
  ## ---- Regression calibration (internal reliability) ----
  RC_InReliab(
    formula   = Y ~ myz(z_1, z_2, z_3, z_4) + W1,
    main_data = main_data,
    link      = "logistic"
  )
}

## ---- Monte Carlo loop ----
B <- 1000
results_list <- replicate(B, simulate_once(), simplify = FALSE)

## ---- Extract naïve and corrected tables
naive_tabs     <- lapply(results_list, function(x) x$uncorrected)
corrected_tabs <- lapply(results_list, function(x) x$corrected)

avg_naive     <- Reduce("+", naive_tabs) / B
avg_corrected <- Reduce("+", corrected_tabs) / B

cat("\nAverage Naive Logistic Estimates (B=", B, "):\n", sep = "")
print(round(avg_naive, 5))

cat("\nAverage Corrected Logistic Estimates (B=", B, "):\n", sep = "")
print(round(avg_corrected, 5))

## ---- Coverage of TRUE OR = 1.5 for z ----
inside_ci <- function(tab, i, truth = OR_true) {
  ci <- tab[i, c("CI.low", "CI.high")]
  truth >= ci[1] && truth <= ci[2]
}

# exposure is always the 2nd row (1st row = intercept, 3rd row = W1)
row_z <- 2

coverage <- function(tab_list, row) {
  mean(sapply(tab_list, function(tab) inside_ci(tab, row))) * 100
}

cov_z_naive <- coverage(naive_tabs, row_z)
cov_z_corr  <- coverage(corrected_tabs, row_z)

cat("\nCoverage of TRUE OR = 1.5 for error-prone exposure z:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z_corr))

## ---- Monte Carlo SD vs mean reported SE for z ----
z_correct_est <- sapply(corrected_tabs, function(tab) tab[row_z, "Estimate"])
z_correct_se  <- sapply(corrected_tabs, function(tab) tab[row_z, "Std. Error"])

sd_mc   <- sd(z_correct_est, na.rm = TRUE)
mean_se <- mean(z_correct_se, na.rm = TRUE)

cat("\nCorrected z:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se))

```

```{r}
# INTERNAL 2Z 0W
library(RegCalReliab)
library(mgcv)
set.seed(123)

# --- Helper to add classical measurement error
add_err <- function(v, sd = sqrt(0.4)) v + rnorm(length(v), 0, sd)

# --- True slope and OR
beta <- log(1.5)
OR_true <- 1.5

simulate_once <- function() {
  ## ---- True exposures (correlated) ----
  x <- mgcv::rmvn(3000, c(0,0), matrix(c(1,0.3,0.3,1), 2))
  
  ## ---- Replicate design: 1, 2, 3, 4 replicates
  r <- c(rep(1,1500), rep(2,500), rep(3,400), rep(4,600))
  
  ## ---- Replicates for z1 ----
  z1 <- rbind(
    cbind(add_err(x[1:1500, 1]), NA, NA, NA),
    cbind(add_err(x[1501:2000, 1]), add_err(x[1501:2000, 1]), NA, NA),
    cbind(add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), add_err(x[2001:2400, 1]), NA),
    cbind(add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]), add_err(x[2401:3000, 1]))
  )
  colnames(z1) <- paste0("z1_", 1:4)
  
  ## ---- Replicates for z2 ----
  z2 <- rbind(
    cbind(add_err(x[1:1500, 2]), NA, NA, NA),
    cbind(add_err(x[1501:2000, 2]), add_err(x[1501:2000, 2]), NA, NA),
    cbind(add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), add_err(x[2001:2400, 2]), NA),
    cbind(add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]), add_err(x[2401:3000, 2]))
  )
  colnames(z2) <- paste0("z2_", 1:4)
  
  ## ---- Outcome ----
  p <- plogis(-2.65 + beta * rowSums(x))
  Y <- rbinom(3000, 1, p)
  
  ## ---- Main data with outcome and replicates only ----
  main_data <- data.frame(Y, z1, z2)
  
  ## ---- Regression calibration (internal reliability) ----
  RC_InReliab(
    formula   = Y ~ myz1(z1_1, z1_2, z1_3, z1_4) +
                  myz2(z2_1, z2_2, z2_3, z2_4),
    main_data = main_data,
    link      = "logistic"
  )
}

## ---- Monte Carlo loop ----
B <- 1000
results_list <- replicate(B, simulate_once(), simplify = FALSE)

## ---- Extract naïve and corrected tables
naive_tabs     <- lapply(results_list, function(x) x$uncorrected)
corrected_tabs <- lapply(results_list, function(x) x$corrected)

avg_naive     <- Reduce("+", naive_tabs) / B
avg_corrected <- Reduce("+", corrected_tabs) / B

cat("\nAverage Naive Logistic Estimates (B=", B, "):\n", sep = "")
print(round(avg_naive, 5))

cat("\nAverage Corrected Logistic Estimates (B=", B, "):\n", sep = "")
print(round(avg_corrected, 5))

## ---- Coverage of TRUE OR = 1.5 for z1 and z2 ----
inside_ci <- function(tab, i, truth = OR_true) {
  ci <- tab[i, c("CI.low", "CI.high")]
  truth >= ci[1] && truth <= ci[2]
}

# rows: 2 = myz1, 3 = myz2
row_z1 <- 2
row_z2 <- 3

coverage <- function(tab_list, row) {
  mean(sapply(tab_list, function(tab) inside_ci(tab, row))) * 100
}

cov_z1_naive <- coverage(naive_tabs, row_z1)
cov_z1_corr  <- coverage(corrected_tabs, row_z1)
cov_z2_naive <- coverage(naive_tabs, row_z2)
cov_z2_corr  <- coverage(corrected_tabs, row_z2)

cat("\nCoverage of TRUE OR = 1.5 for error-prone exposure z1:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z1_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z1_corr))

cat("\nCoverage of TRUE OR = 1.5 for error-prone exposure z2:\n")
cat(sprintf("  • Naive                 : %5.1f %%\n", cov_z2_naive))
cat(sprintf("  • Regression Calibration: %5.1f %%\n", cov_z2_corr))

## ---- Monte Carlo SD vs mean reported SE for z1 and z2 ----
z1_correct_est <- sapply(corrected_tabs, function(tab) tab[row_z1, "Estimate"])
z1_correct_se  <- sapply(corrected_tabs, function(tab) tab[row_z1, "Std. Error"])
z2_correct_est <- sapply(corrected_tabs, function(tab) tab[row_z2, "Estimate"])
z2_correct_se  <- sapply(corrected_tabs, function(tab) tab[row_z2, "Std. Error"])

sd_mc1  <- sd(z1_correct_est, na.rm = TRUE)
mean_se1<- mean(z1_correct_se, na.rm = TRUE)
sd_mc2  <- sd(z2_correct_est, na.rm = TRUE)
mean_se2<- mean(z2_correct_se, na.rm = TRUE)

cat("\nCorrected z1:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc1))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se1))

cat("\nCorrected z2:\n")
cat(sprintf("  Monte Carlo SD (mc_sd) : %.4f\n", sd_mc2))
cat(sprintf("  Mean reported SE (ese) : %.4f\n", mean_se2))

```

